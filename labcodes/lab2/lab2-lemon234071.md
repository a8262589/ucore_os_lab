







练习一：

通过实验前后分析，练习一要求实现first fit算法，将连续空闲内存首页（答案中将每一页，并未弄清为何），按地址高低顺序正确保存在链表中，并在分配回收中，正确插入链表。

1、根据注释着手完整lab2代码；参看list.h、le2page、PageReserved（此汇编语义未查清）、SetPageProperty并在piazza上搜索相关信息，完成对链表和宏、内联汇编的理解。

default_init_memmap：
2、对for (; p != base + n; p ++) ：中p++跳转（到8192）未理解，通过帖子弄懂：https://piazza.com/class/i5j09fnsl7k5x0?cid=554

3、make qemu出现bug，通过调试并参阅answer对answer中每一页SetPageProperty(p)不理解，认为与PG_property注释不符，参看piazza帖子中助教回答更糊涂了：
https://piazza.com/class/i5j09fnsl7k5x0?cid=1021    
https://piazza.com/class/i5j09fnsl7k5x0?cid=686
https://piazza.com/class/i5j09fnsl7k5x0?cid=192   //暂且按此贴中助教所述PG_property置一则可以用于分配，进行实验。


练习一总结：
basic_check后有bug，从新理清思路：保证连续空闲页首页链入链表，flag置位，分配回收亦需要准守此规则，回收时需要“左顾右盼”合并空闲页。check_alloc_pages()succeed!

通过参阅大佬的实现发现问题、以及优化改进如下：
错误实现：我的视线中链表中未按首地址递增排序，修改各函数。
算法改进：优化合并，查找效率。

练习二：
1、按注释填写代码即可，此处最重要的是明白原理、理清思路。

2、填写代码中check失败，原因是目录项中、页表项中是物理地址！不是线性地址！要搞清楚。其次要把练习三也填写好才能过check！

3、没有判断alloc失败的情况，鲁棒性差，补上！

练习二总结：做完了实验发现实验指导书练习描述下面有对练习的讲解orz。。。。所以说原理的理解实现思路很重要，对页机制的理解很重要。

描述PDE：
 31                12 11 10 9 8 7 6 5 4 3 2 1 0
+--------------------+-------+-+-+-+-+-+-+-+-+-+
|                    |       | |P| | |P|P|U|R| |
|   页表基址高20位   |忽略   |G|S|0|A|C|W|/|/|P|
|                    |       | | | | |D|T|S|W| |
+--------------------+-------+-+-+-+-+-+-+-+-+-+
【P】：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。 
【R/W】：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。 
【U/S】：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。 
【PWT】：Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉），此标志被忽略。对于我们的实验，此位清零。 
【PCD】：Page级的Cache Disable标志位。为1时，物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时，此标志被忽略。对于我们的实验，此位清零。 
【A】：访问位。该位由处理器固件设置，用来指示此表项所指向的页是否已被访问（读或写），一旦置位，处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率。 
【PS】：Page Size位。为0时，页的大小是4KB；为1时，页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled). 
【G】：不使用。
【AVL】：被处理器忽略，软件可以使用。
【页表基址】：页表的物理地址，需要4KB对齐，所以只需填写高20位
【忽略】：内核可以记录自己需要的信息

描述PTE：
 31                12 11 10 9 8 7 6 5 4 3 2 1 0
+--------------------+-------+-+-+-+-+-+-+-+-+-+
|                    |       | | | | |P|P|U|R| |
|   页基址高20位     |忽略   |G|0|D|A|C|W|/|/|P|
|                    |       | | | | |D|T|S|W| |
+--------------------+-------+-+-+-+-+-+-+-+-+-+
【P】：存在位。为1表示页表或者页位于内存中。否则，表示不在内存中，必须先予以创建或者从磁盘调入内存后方可使用。 
【R/W】：读写标志。为1表示页面可以被读写，为0表示只读。当处理器运行在0、1、2特权级时，此位不起作用。页目录中的这个位对其所映射的所有页面起作用。 
【U/S】：用户/超级用户标志。为1时，允许所有特权级别的程序访问；为0时，仅允许特权级为0、1、2的程序访问。页目录中的这个位对其所映射的所有页面起作用。 
【PWT】：Page级的Write-Through标志位。为1时使用Write-Through的Cache类型；为0时使用Write-Back的Cache类型。当CR0.CD=1时（Cache被Disable掉），此标志被忽略。对于我们的实验，此位清零。 
【PCD】：Page级的Cache Disable标志位。为1时，物理页面是不能被Cache的；为0时允许Cache。当CR0.CD=1时，此标志被忽略。对于我们的实验，此位清零。 
【A】：访问位。该位由处理器固件设置，用来指示此表项所指向的页是否已被访问（读或写），一旦置位，处理器从不清这个标志位。这个位可以被操作系统用来监视页的使用频率。 
【D】：脏位。该位由处理器固件设置，用来指示此表项所指向的页是否写过数据。 
【PS】：Page Size位。为0时，页的大小是4KB；为1时，页的大小是4MB（for normal 32-bit addressing ）或者2MB（if extended physical addressing is enabled). 
【G】：全局位。如果页是全局的，那么它将在高速缓存中一直保存。当CR4.PGE=1时，可以设置此位为1，指示Page是全局Page，在CR3被更新时，TLB内的全局Page不会被刷新。 
【AVL】：被处理器忽略，软件可以使用。
【页基地址】：页面的物理地址，需要4KB对齐，所以只需填写高20位
【忽略】：内核可以记录自己需要的信息

如果出现页访问异常，硬件要保存断点，关中断，根据中断向量跳转到服务例程地址，确认是否发生特权级转换并做相应处理，保存被打断的现场，CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，
开始执行中断服务例程，每个中断服务例程在有中断处理工作完成后需要通过iret（或iretd）指令恢复被打断的程序的执行。

练习三：
1、按注释填写代码即可。
2、对比答案发现在特殊情况下会出现BUG，补改。

以PDE\PTE高20位为数组（pages)的偏移既是该页指针。

实现虚拟地址与物理地址相等需要：。。。。。。

注释：
struct Page //每一个物理页属性描述结构

关于系统启动后各阶段地址映射：。。。。。。
