与参考答案对比：  
练习0：  

	1、trap.c中我未assert(current != NULL)
  

本实验中重要知识点：  
  
	*基于关中断的单核处理器的互斥  
	*信号量  
	*条件变量
	*管程 
	*哲学家算法
	*死锁
很重要但未对应的知识点：
	
	*死锁处理
	*进程通信

练习1：
请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。  

	当多个（>1）进程可以进行互斥或同步合作时，一个进程会
	由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明
	条件满足了）。为了发信号，需要使用一个称作信号量的特殊变量。为通过信号量s传送信
	号，信号量的V操作采用进程可执行原语semSignal(s)；为通过信号量s接收信号，信号量的P
	操作采用进程可执行原语semWait(s)；如果相应的信号仍然没有发送，则进程被阻塞或睡
	眠，直到发送完为止。

请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。  

	异同
练习2：  

请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。  

	一个条件变量CV可理解为一个进程的等待队列，队列中的进程正等待某个条件Cond变为真。
	每个条件	变量关联着一个条件，如果条件Cond不为真，则进程需要等待，如果条件
	Cond为真，则进程可以进一步在管程中执行。需要注意当一个进程等待一个条件变量CV
	（即等待Cond为真），该进程需要退出管程，这样才能让其它进程可以进入该管程执行，
	并进行相关操作，比如设置条件Cond为真，改变条件变量的状态，并唤醒等待在此条件
	变量CV上的进程。因此对条件
	变量CV有两种主要操作：
	wait_cv： 被一个进程调用，以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件
	变量上等待时，不被认为是占用了管程。
	signal_cv：被一个进程调用，以指出断言Pc现在为真，从而可以唤醒等待断言Pc被满足
	的进程继续执行。

请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。  

	异同	
请在实验报告中回答：能否不用基于信号量机制来完成条件变量？如果不能，请给出理由，如果能，请给出设计说明和具体实现。  

	